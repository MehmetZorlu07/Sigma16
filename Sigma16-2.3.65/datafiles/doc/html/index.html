<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Sigma16 System</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">Sigma16 System</h1>
<h3 class="date">version:	  2.3.65</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#how-to-run-the-program">How to run the program</a></li>
<li><a href="#tutorial-run-an-example-program">Tutorial: Run an example program</a></li>
<li><a href="#using-the-user-interface">Using the user interface</a><ul>
<li><a href="#editor">Editor</a></li>
<li><a href="#assembler">Assembler</a></li>
<li><a href="#processor">Processor</a></li>
</ul></li>
</ul></li>
<li><a href="#programs-modules-and-files">Programs, modules, and files</a><ul>
<li><a href="#simple-standalone-programs">Simple standalone programs</a></li>
<li><a href="#programs-with-multiple-modules">Programs with multiple modules</a></li>
</ul></li>
<li><a href="#architecture-of-the-computer">Architecture of the computer</a><ul>
<li><a href="#data-representation">Data representation</a></li>
<li><a href="#register-file">Register file</a></li>
<li><a href="#control-registers">Control registers</a></li>
<li><a href="#condition-codes">Condition codes</a></li>
<li><a href="#processor-status-flags">Processor status flags</a></li>
<li><a href="#memory">Memory</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul></li>
<li><a href="#instruction-set">Instruction set</a><ul>
<li><a href="#instruction-formats">Instruction formats</a><ul>
<li><a href="#rrr-format">RRR format</a></li>
<li><a href="#rx-format">RX format</a></li>
<li><a href="#exp-format">EXP format</a></li>
</ul></li>
<li><a href="#summary-of-the-instruction-set">Summary of the instruction set</a></li>
<li><a href="#instructions">Instructions</a><ul>
<li><a href="#load">load</a></li>
<li><a href="#mul-multiply-signed-integers">mul (multiply signed integers)</a></li>
<li><a href="#add">add</a></li>
</ul></li>
</ul></li>
<li><a href="#assembly-language">Assembly Language</a><ul>
<li><a href="#notation">Notation</a></li>
<li><a href="#assembly-instruction-fields">Assembly instruction fields</a></li>
<li><a href="#expressions">Expressions</a></li>
<li><a href="#assembly-language-statements">Assembly language statements</a><ul>
<li><a href="#instructions-1">Instructions</a></li>
<li><a href="#directives">Directives</a></li>
</ul></li>
<li><a href="#object-language-statements">Object language statements</a></li>
<li><a href="#assembly-listing">Assembly listing</a></li>
</ul></li>
<li><a href="#linker">Linker</a></li>
<li><a href="#programming-the-sigma16-architecture">Programming the Sigma16 architecture</a></li>
<li><a href="#using-the-graphical-user-interface">Using the graphical user interface</a></li>
<li><a href="#about-the-software">About the software</a><ul>
<li><a href="#changes-underway">Changes underway</a></li>
</ul></li>
<li><a href="#installation">Installation</a><ul>
<li><a href="#using-a-precompiled-installation">Using a precompiled installation</a></li>
<li><a href="#building-from-source">Building from source</a><ul>
<li><a href="#hiding-the-console-on-windows">Hiding the console on Windows</a></li>
</ul></li>
<li><a href="#using-a-pre-compiled-directory">Using a pre-compiled directory</a><ul>
<li><a href="#compiling-from-source">Compiling from source</a></li>
<li><a href="#prerequisite-software">Prerequisite software</a></li>
</ul></li>
</ul></li>
<li><a href="#reference">Reference</a><ul>
<li><a href="#summary-of-notation">Summary of notation</a></li>
</ul></li>
</ul>
</div>
<h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p>Sigma16 is a computer architecture designed for research and teaching in computer systems. This application provides a complete environment for experimenting with the architecture, including an editor, assembler, linker, emulator, and an integrated development environment. There is a digital circuit that implements the architecture, which is specified using the Hydra functional hardware description language. Hydra can simulate the circuit, and machine language programs can run on both the emulator and the circuit.</p>
<p>This reference manual is organised by topic, with chapters on the architecture, the assembly language, and the emulator. However, it's a good idea to begin with an overview of how the whole system works, and to be able to write and run simple programs, before delving into the details. For a quick start, begin with the following tutorials.</p>
<h2 id="how-to-run-the-program"><a href="#how-to-run-the-program">How to run the program</a></h2>
<p>Summary: launch <em>Sigma16.exe</em> and visit <em>http://localhost:8023</em> in your browser.</p>
<p>The program is a standalone application that runs in any standard system (Windows, Macintosh, Linux). It uses a web browser to display the graphical user interface (currently it works with Chrome and Firefox). Unzip the installation file and enter the directory. To run the application you need to do two things:</p>
<ol style="list-style-type: decimal">
<li><p>Launch the program, using any one of the following methods</p>
<ul>
<li><p>Run the executable file: click <em>Sigma16.exe</em></p></li>
<li><p>If there is no executable file, run the program from source: enter <em>bash run</em> in a shell. (This requires that you have the Haskell compiler ghc installed. If you're using cygwin, then enter bash runcygwin.)</p></li>
<li><p>You can compile the program, using the makefile.</p></li>
</ul></li>
<li><p>Open the graphical user interface in a browser</p>
<ul>
<li>Visit the following address in your browser: http://localhost:8023 If you get an error on your browser, something like <em>This site can't be reached, localhost refused to connect</em>, that means the program isn't running. Launch it and the web page should connect.</li>
</ul></li>
</ol>
<h2 id="tutorial-run-an-example-program"><a href="#tutorial-run-an-example-program">Tutorial: Run an example program</a></h2>
<p>A good way to get started is to go through the entire process of entering a simple program, assembling it, and running it. This section shows you how. For now, we focus just on how to use the software tools; an explanation of the Sigma16 architecture comes later.</p>
<p>When you launch the application, a window will appear in your browser. It has several panes, with buttons at the top to switch between panes. The Welcome pane will be visible.</p>
<ul>
<li><p>Click <strong>Editor</strong> to show the Editor Pane. <em>(You can edit code here or use an external text editor and copy/paste text into the editor.)</em></p></li>
<li><p>Click <strong>Example</strong> to load a simple example program.</p></li>
<li><p>Click the <strong>Assembler</strong> tab. The assembler page is where you translate a program from assembly language to machine language.</p></li>
<li><p>Click the <strong>Assemble</strong> button. The assembly listing, showing the translation to machine language, will appear. This example program doesn't produce any error messages, so we can move on.</p></li>
<li><p>For this simple example, we don't need the Linker, so you can skip it. <em>(The linker is needed for programs with multiple modules, or with external references, or that need relocation.)</em></p></li>
<li><p>Click the <strong>Processor</strong> tab, which shows the main components of the processor. This is where you can run programs using the emulator. The state of the processor is displayed as it runs your program, and the assembly listing is shown below, to help you follow the execution of the program.</p></li>
<li><p>Click <strong>Boot</strong>. This reads the machine language program into the memory, and you can see it in the Memory display. There are two independent views into the memory; this is convenient for looking at the machine language code in one view and the data in the other view. (Despite the two views, there is just one memory!) At this point the pc register contains 0, meaning that the next instruction to be executed is the one in memory location 0. The ir and other registers also contain 0, but that is just the initial value.</p></li>
<li><p>Click <strong>Step</strong>. The emulator executes a single instruction and displays the effects on the registers and memory: blue for using a value, and red for modifying it.</p></li>
<li><p>Click Step repeatedly to watch the program execute, instruction by instruction.</p></li>
<li><p>To rerun the program, click Boot again.</p></li>
<li><p>To run the program slowly, click <strong>Run Display</strong>, which is similar to clicking Step repeatedly. To run the program faster but without updating the display after each instruction, click Run. At any time you can click Pause to stop the processor, and you can resume execution with any of Step, Slow, or Run.</p></li>
<li><p>To set a breakpoint, click Breakpoint and enter the stopping condition in the dialogue box. For example, to stop when the pc register becomes $01b7, enter BPeq BPpc (BPhex &quot;01b7&quot;). Then click Run, and the emulator will run at full speed until the pc reaches the specified value; then it will stop so you can examine the state of the machine.</p></li>
</ul>
<h2 id="using-the-user-interface"><a href="#using-the-user-interface">Using the user interface</a></h2>
<h3 id="editor"><a href="#editor">Editor</a></h3>
<h3 id="assembler"><a href="#assembler">Assembler</a></h3>
<h3 id="processor"><a href="#processor">Processor</a></h3>
<h1 id="programs-modules-and-files"><a href="#programs-modules-and-files">Programs, modules, and files</a></h1>
<p>The system is designed to allow programs that consist of several modules, but also to allow programs consisting of one standalone module. In addition, an aim is to do this simply and intuitively, so that you can ignore the issues of modules and linking if you just want to write a andalone program.</p>
<p>There is a standard convention for file names. If, for example, you have a program named MyProgram, then the files associated with it should be as follows:</p>
<pre><code>-----------------  -----------
module name        MyProgram
source file        MyProgram.asm.txt
object file        MyProgram.obj.txt
assembly listing   MyProgram.lst.txt
-----------------  -----------</code></pre>
<h2 id="simple-standalone-programs"><a href="#simple-standalone-programs">Simple standalone programs</a></h2>
<p>If a program does not import any names, it is <em>standalone</em>. The text of the program is shown in the editor pane. Go to the Assembler pane and click Assemble. If there are no errors, go directly to the Processor pane (you can skip the Linker) and click Boot. This will read the machine language into the memory, and now you can run the program.</p>
<h2 id="programs-with-multiple-modules"><a href="#programs-with-multiple-modules">Programs with multiple modules</a></h2>
<p>A module consists of program text, and it may have an optional file, and an optional module name.</p>
<ul>
<li><p>The module text is a sequence of assembly language statements. The text may exist only in the editor buffer, or it may be associated with a file.</p></li>
<li><p>If there is a file, this may be specified either as a path (the unique identification of the file (C:\Users....asm.txt), or as just a filename (myprogram.asm.txt) which is relative to the current directory.</p></li>
</ul>
<p>To edit a file, the modDir and modName are both optional. An edited file may have a module name specified with a module statement. To read or save a file, both the module directory and name must be known.</p>
<p>Editor operations on files and modules</p>
<p>Each operation that changes the editor buffer (New, Open, Close) checks first to see whehter the buffer has been changed since it was last saved. If so, a dialogue asks whether the file should be saved.</p>
<ul>
<li><p>New -- Check whether text in the editor buffer has been saved; if not, ask whether to save it. Create a new module with empty text and no file name, add it to the module set, and select it as the current module. Clear the text in the editor buffer.</p></li>
<li><p>Open -- Check whether text in the editor buffer has been saved; if not, ask whether to save it. Enter the open file dialogue where an existing file can be found by navigation or by typing in its name. If the dialogue is cancelled, the module set and editor buffer are left unchanged. If a file is selected in the dialogue, and it is already in the module set, then it is selected in the current module. Otherwise, a new module is created with the file's contents, and is selected as the current module. and The file is loaded into the editor buffer and added to the module set.</p></li>
<li><p>Refresh -- The file corresponding to the current module is read, and its contents are loaded into the editor buffer.</p></li>
<li><p>SaveAs -- Enters the save file dialogue where the directory and file name can be chosen. The editor buffer is written into this file.</p></li>
<li><p>Save -- Writes the editor buffer into the current file and directory. If either the module name or directory is not known, this reverts to a SaveAs.</p></li>
<li><p>Select -- Opens a list of all modules; you can click one of them which is then set as the current module.</p></li>
<li><p>Close -- Check whether text in the editor buffer has been saved; if not, ask whether to save it. The module is removed from the module set, and the editor buffer is cleared. The first module (module number 0) is selected as the current module, but if there is no module at all, an empty module is created and selected as current (in effect, if there is only one module and you close it, an automatic New is performed).</p></li>
<li><p>Example -- Reads in a very simple example program and sets it as the current module. This is a standalone program; you can simply click Editor: Example, then Assembler: Assemble, then Processor: Boot, and run the program. This example is used in the first &quot;getting started&quot; tutorial. The example program is also available in the Examples directory, accessible through Editor: Open.</p></li>
</ul>
<p>Select is for switching among the existing modules, while New and Open are for introducing a new module.</p>
<h1 id="architecture-of-the-computer"><a href="#architecture-of-the-computer">Architecture of the computer</a></h1>
<p>An <em>instruction set architecture</em> is a precise specification of all aspects of a machine that are visible to a programmer. It includes a description of the registers, memory, data representations, and all the instructions, but does not include components of the implementation that are not visible to a machine language programmer.</p>
<h2 id="data-representation"><a href="#data-representation">Data representation</a></h2>
<p>Sigma16 is a 16-bit architecture, and every data value is a 16-bit word. Integers are represented in 16-bit two's complement notation. The bits of a word are numbered from left to right, starting with 0. Thus the leftmost (most significant) bit of a word is bit 0, and the rightmost (least significant) is bit 15.</p>
<h2 id="register-file"><a href="#register-file">Register file</a></h2>
<p>The <strong>register file</strong> is a set of 16 general registers that hold a 16 bit word. A register is referenced by a 4-bit binary number. In assembly language, we use the notations R0, R1, R2, ..., R9, R10, R11, R12, R13, R14, R15 to refer to the registers.</p>
<p>One of the registers, R0, has a special property: it always contains the constant 0. It is legal to perform an instruction that attempts to load some other value into R0, but the register will still contain 0 after executing such an instruction. Such an instruction will simply have no lasting effect.</p>
<p>Apart from R0, all the instructions behave exactly the same way, at least as far as the hardware is concerned.</p>
<p>There are some programming conventions that use certain registers for special purposes. The hardware does not enforce, or even know about, these conventions, and you do not have to follow the conventions in programming. However, it is necessary to obey the conventions in order to use the standard software libraries in your program. See the section on Programming for a discussion of these standard usage conventions.</p>
<h2 id="control-registers"><a href="#control-registers">Control registers</a></h2>
<p>There are several <strong>program control registers</strong> that enable the processor to keep track of the state of the running program. These registers are rarely used directly by the machine language program, but they are essential for keeping track of the execution of the program, and some instructions use them directly.</p>
<ul>
<li><p>ir -- instruction register (16-bit word)</p></li>
<li><p>pc -- program counter (16-bit word)</p></li>
<li><p>adr -- address register (16-bit word)</p></li>
<li><p>dat -- data register (16-bit word)</p></li>
</ul>
<h2 id="condition-codes"><a href="#condition-codes">Condition codes</a></h2>
<p>Several instructions produce status information: the result of a comparison, whether there was an overflow, etc. This information is automatically loaded into R15, which is the condition code register. The description of each instruction states whether R15 is modified, and what goes into it.</p>
<p>The bits in R15 are indexed from bit 0 (the least significant, or rightmost bit) to bit 15 (the most significant, or leftmost). The condition code bits that have specific meanings are called <em>flags</em>. The flags are defined to make the condition code easier to read in hex: comparison flags are in the rightmost hex digit, and the carry and overflow flags are in the hex digit to the left.</p>
<table>
<caption>Condition code flags</caption>
<thead>
<tr class="header">
<th align="center">Bit</th>
<th align="center">Flag</th>
<th align="left">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="center"><strong>G</strong> &gt;</td>
<td align="left">(or &gt;0) unsigned (binary)</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="center"><strong>g</strong> &gt;</td>
<td align="left">(or &gt;0) signed (two's complement)</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="center"><strong>E</strong> =</td>
<td align="left">(or =0) word, signed, unsigned</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="center"><strong>l</strong> &lt;</td>
<td align="left">(or &lt;0) signed (two's complement)</td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="center"><strong>L</strong> &lt;</td>
<td align="left">(or &lt;0) unsigned (binary)</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="center"><strong>V</strong> u</td>
<td align="left">nsigned overflow (binary)</td>
</tr>
<tr class="odd">
<td align="center">6</td>
<td align="center"><strong>v</strong> s</td>
<td align="left">igned overflow (two's complement)</td>
</tr>
<tr class="even">
<td align="center">7</td>
<td align="center"><strong>C</strong> c</td>
<td align="left">arry propagation (binary)</td>
</tr>
</tbody>
</table>
<p>conditional jump</p>
<p>jumpc0 jump if cc bit is 0 jumpc1 jump if cc bit is 1</p>
<h2 id="processor-status-flags"><a href="#processor-status-flags">Processor status flags</a></h2>
<p>The processor can be executing in several modes, which are determined by the <strong>system control registers</strong>.</p>
<ul>
<li><p>ie -- interrupts enabled (1-bit flag)</p></li>
<li><p>sys -- system state (1-bit flag)</p></li>
</ul>
<h2 id="memory"><a href="#memory">Memory</a></h2>
<p>The memory is a hardware array of words that are accessed by address. A memory address is 16 bits wide, and there is one memory location corresponding to each address, so there are 2^16 = 64k memory locations. Each memory location is a 16-bit word.</p>
<h2 id="exceptions"><a href="#exceptions">Exceptions</a></h2>
<table>
<thead>
<tr class="header">
<th align="center">Location</th>
<th align="left">Exception</th>
<th align="left">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0</td>
<td align="left">Trap</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">1</td>
<td align="left">Overflow</td>
<td align="left">Trap</td>
</tr>
<tr class="odd">
<td align="center">2</td>
<td align="left">Div0</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">3</td>
<td align="left">SegFault</td>
<td align="left">Trap</td>
</tr>
<tr class="odd">
<td align="center">4</td>
<td align="left">Privilege</td>
<td align="left">Trap</td>
</tr>
<tr class="even">
<td align="center">5</td>
<td align="left">Timer</td>
<td align="left">Interrupt</td>
</tr>
<tr class="odd">
<td align="center">6</td>
<td align="left">Input</td>
<td align="left">Interrupt</td>
</tr>
<tr class="even">
<td align="center">7</td>
<td align="left">Output</td>
<td align="left">Interrupt</td>
</tr>
</tbody>
</table>
<h1 id="instruction-set"><a href="#instruction-set">Instruction set</a></h1>
<p>Sigma16 is a load/store style architecture; that is, it does not combine memory accesses with arithmetic. All calculations are carried out in the register file, and explicit load and store instructions must be used to copy data between the memory and the register file.</p>
<h2 id="instruction-formats"><a href="#instruction-formats">Instruction formats</a></h2>
<p>There are three instruction formats:</p>
<ul>
<li><p>RRR -- (1 word) Instructions that perform operations on data in registers, but not referring to memory.</p></li>
<li><p>RX -- (2 words) Instructions that specify a memory location, as well as a register operand.</p></li>
<li><p>EXP -- (2 words) Expanded instructions, for instructions that cannot be encoded as RRR or RX.</p></li>
</ul>
<p>The first word of an instruction contains four 4-bit fields, named op (bits 0-3), d (bits 4-7), sa (bits 8-11), and sb (bits 12-15).</p>
<p>Each instruction has a 4-bit field called the opcode (op for short). This gives 16 values of the opcode: 14 of them denote the 14 RRR instructions, while two of these values indicate that the instruction is either RX or XX format, and there is then a secondary opcode in the sb field</p>
<p>Expanding opcodes</p>
<pre><code>        e     XX format
        f     RX format</code></pre>
<h3 id="rrr-format"><a href="#rrr-format">RRR format</a></h3>
<p>An RRR instruction contains an operation code (op), and specifies three operands registers using the d, sa, and sb fields. It is represented as one word, which is divided into four fields:</p>
<div class="figure">
<img src="figures/RRRformat.png" alt="RRR instruction format" /><p class="caption"><strong>RRR instruction format</strong></p>
</div>
<ul>
<li>op (4 bits, starting from bit 0) Operation code</li>
<li>d (4 bits, starting from bit 4) Destination register</li>
<li>sa (4 bits, starting from bit 8) Source a register</li>
<li>sb (4 bits, starting from bit 12) Source b register</li>
</ul>
<p>The op field of an RRR instruction must be in the range from 0 through 13 (hex 0 through d). This allows for a total of 14 distinct RRR instructions. If the op field is outside this range, it indicates an &quot;expanding opcode&quot;: 14 (hex e) indicates the EXP format, and 15 (hex f) indicates the RX format.</p>
<p>A typical example of an RRR instruction is add R4,R9,R2, which adds the contenst of registers R9 and R2, and loads the result into R4. It's equivalent to R4 := R9 + R2.</p>
<p>The following table summarises the RRR instructions. Most of the instructions take two operands, which are specified in the sa and sb fields, and produce a result which is loaded into the destination register. However, a few instructions vary from this pattern. Detailed specifications of the instructions are given below the table.</p>
<h3 id="rx-format"><a href="#rx-format">RX format</a></h3>
<p>The RX instruction format is used for instructions that use a memory address, which is specified by an index register and a displacement. The name of the format describes briefly the two operands: a register (R) and an indexed memory address (X).</p>
<div class="figure">
<img src="figures/RXformat.png" alt="RX instruction format" /><p class="caption"><strong>RX instruction format</strong></p>
</div>
<p>An RX instruction contains two operands: one is a memory address, and the other is a register. Typical RX instructions are loads, stores, and jumps. The instruction consists of two consecutive words. The first has the same format as an RRR instruction, with four fields: op, d, sa, sb. The second word is a single 16-bit binary number, and is called the displacement.</p>
<p>The memory address is specified in two parts: an index register and the displacement. The index register is specified in the sa field. In assembly language, the notation used is number[reg], where the number is the value of the displacement, and the reg is the index register. Thus $20b3[R2] means the address has displacement $20b3 and the index register is R2.</p>
<p>When the machine executes an RX instruction, it begins by calculating the effective address. This is abbreviated &quot;ea&quot;, and its value is the sum of the displacement and the contents of the index register.</p>
<p>RX instructions are represented in two words, and they use an &quot;expanding opcode&quot;. That is, the op field of the first word of the instruction contains the constant f (the bits 1111) for every RX instruction, and the sb field is used to hold a secondary opcode indicating which RX instruction it is.</p>
<p>The register operand is specified in the d field. For several RX instructions, this is indeed the destination of the instruction: for example, load places data into Rd. However, a few RX instructions use the d field differently (see, for example, the conditional jump instructions).</p>
<p>The memory address is specified using the sa field and the displacement, which is the entire second word of the instruction.</p>
<h3 id="exp-format"><a href="#exp-format">EXP format</a></h3>
<p>The EXP instruction format is used for expanded instructions cannot be represented using the RRR or RX formats. It provides many unused opcodes, so it is useful for experimental instructions.</p>
<div class="figure">
<img src="figures/EXPformat.png" alt="EXP instruction format" /><p class="caption"><strong>EXP instruction format</strong></p>
</div>
<p>An EXP instruction consists of two words. The first word has a constant hex e in the op field, which indicates the EXP format. The opx1 and opx2 fields constitute an 8-bit expanded opcode. The d, sa, and sb fields in the second word are used for three register operands.</p>
<h2 id="summary-of-the-instruction-set"><a href="#summary-of-the-instruction-set">Summary of the instruction set</a></h2>
<hr />
<table>
<col width="12%" />
<col width="9%" />
<col width="6%" />
<col width="9%" />
<col width="26%" />
<thead>
<tr class="header">
<th align="left">Mnemonic</th>
<th align="left">Format</th>
<th align="left">Op</th>
<th align="left">Notes</th>
<th align="left">Effect</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">add</td>
<td align="left">RRR</td>
<td align="left">0</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] + r[b] signed +</td>
</tr>
<tr class="even">
<td align="left">sub</td>
<td align="left">RRR</td>
<td align="left">1</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] - r[b] signed -</td>
</tr>
<tr class="odd">
<td align="left">mul</td>
<td align="left">RRR</td>
<td align="left">2</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] * r[b] signed *</td>
</tr>
<tr class="even">
<td align="left">div</td>
<td align="left">RRR</td>
<td align="left">3</td>
<td align="left">E</td>
<td align="left">r[d] := r[a] div r[b], R15 := r[a] rem r[b]</td>
</tr>
<tr class="odd">
<td align="left">cmp</td>
<td align="left">RRR</td>
<td align="left">?</td>
<td align="left"></td>
<td align="left">R15 := comparison result (both signed, unsigned)</td>
</tr>
<tr class="even">
<td align="left">cmplt</td>
<td align="left">RRR</td>
<td align="left">4</td>
<td align="left"></td>
<td align="left">r[d] := r[a] &lt; r[b]</td>
</tr>
<tr class="odd">
<td align="left">cmpeq</td>
<td align="left">RRR</td>
<td align="left">5</td>
<td align="left"></td>
<td align="left">r[d] := r[a] = r[b]</td>
</tr>
<tr class="even">
<td align="left">cmpgt</td>
<td align="left">RRR</td>
<td align="left">6</td>
<td align="left"></td>
<td align="left">r[d] := r[a] &gt; r[b]</td>
</tr>
<tr class="odd">
<td align="left">test</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">r[d] := r[a][bit b]</td>
</tr>
<tr class="even">
<td align="left">inv</td>
<td align="left">RRR</td>
<td align="left">7</td>
<td align="left"></td>
<td align="left">r[d] := inv r[a]</td>
</tr>
<tr class="odd">
<td align="left">and</td>
<td align="left">RRR</td>
<td align="left">8</td>
<td align="left"></td>
<td align="left">r[d] := r[a] and r[b]</td>
</tr>
<tr class="even">
<td align="left">or</td>
<td align="left">RRR</td>
<td align="left">9</td>
<td align="left"></td>
<td align="left">r[d] := r[a] or r[b]</td>
</tr>
<tr class="odd">
<td align="left">xor</td>
<td align="left">RRR</td>
<td align="left">a</td>
<td align="left"></td>
<td align="left">r[d] := r[a] xor r[b]</td>
</tr>
<tr class="even">
<td align="left">shiftl</td>
<td align="left">RRR</td>
<td align="left">b</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] shl b</td>
</tr>
<tr class="odd">
<td align="left">shiftr</td>
<td align="left">RRR</td>
<td align="left">c</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] shr b</td>
</tr>
<tr class="even">
<td align="left">trap</td>
<td align="left">RRR</td>
<td align="left">d</td>
<td align="left">E</td>
<td align="left">xa := pc, pc := 0</td>
</tr>
<tr class="odd">
<td align="left">lea</td>
<td align="left">RX</td>
<td align="left">f,0</td>
<td align="left"></td>
<td align="left">r[d] := ea</td>
</tr>
<tr class="even">
<td align="left">load</td>
<td align="left">RX</td>
<td align="left">f,1</td>
<td align="left">E</td>
<td align="left">r[d] := m[ea]</td>
</tr>
<tr class="odd">
<td align="left">store</td>
<td align="left">RX</td>
<td align="left">f,2</td>
<td align="left">E</td>
<td align="left">m[ea] := r[d]</td>
</tr>
<tr class="even">
<td align="left">jump</td>
<td align="left">RX</td>
<td align="left">f,3</td>
<td align="left">E</td>
<td align="left">pc := ea</td>
</tr>
<tr class="odd">
<td align="left">jumpf</td>
<td align="left">RX</td>
<td align="left">f,4</td>
<td align="left">E</td>
<td align="left">if not r[d] then pc := ea</td>
</tr>
<tr class="even">
<td align="left">jumpt</td>
<td align="left">RX</td>
<td align="left">f,5</td>
<td align="left">E</td>
<td align="left">if r[d] then pc := ea</td>
</tr>
<tr class="odd">
<td align="left">jal</td>
<td align="left">RX</td>
<td align="left">f,6</td>
<td align="left">E</td>
<td align="left">r[d] := pc, pc := ea</td>
</tr>
<tr class="even">
<td align="left">inton</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">ie := 1</td>
</tr>
<tr class="odd">
<td align="left">intoff</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">ie := 0</td>
</tr>
<tr class="even">
<td align="left">sysoff</td>
<td align="left">EXP</td>
<td align="left"></td>
<td align="left">P</td>
<td align="left">sys := 0</td>
</tr>
<tr class="odd">
<td align="left">getrem</td>
<td align="left">EXP</td>
<td align="left">e,00</td>
<td align="left"></td>
<td align="left">r[d] := rem</td>
</tr>
<tr class="even">
<td align="left">putrem</td>
<td align="left">EXP</td>
<td align="left">e,01</td>
<td align="left"></td>
<td align="left">rem := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getcsa</td>
<td align="left">EXP</td>
<td align="left">e,02</td>
<td align="left">P</td>
<td align="left">r[d] := csa</td>
</tr>
<tr class="even">
<td align="left">putcsa</td>
<td align="left">EXP</td>
<td align="left">e,03</td>
<td align="left">P</td>
<td align="left">csa := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getcsl</td>
<td align="left">EXP</td>
<td align="left">e,04</td>
<td align="left">P</td>
<td align="left">r[d] := csl</td>
</tr>
<tr class="even">
<td align="left">putcsl</td>
<td align="left">EXP</td>
<td align="left">e,05</td>
<td align="left">P</td>
<td align="left">csl := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getdsa</td>
<td align="left">EXP</td>
<td align="left">e,06</td>
<td align="left">P</td>
<td align="left">r[d] := dsa</td>
</tr>
<tr class="even">
<td align="left">putdsa</td>
<td align="left">EXP</td>
<td align="left">e,07</td>
<td align="left">P</td>
<td align="left">dsa := r[d]</td>
</tr>
<tr class="odd">
<td align="left">getdsl</td>
<td align="left">EXP</td>
<td align="left">e,08</td>
<td align="left">P</td>
<td align="left">r[d] := dsl</td>
</tr>
<tr class="even">
<td align="left">putdsl</td>
<td align="left">EXP</td>
<td align="left">e,09</td>
<td align="left">P</td>
<td align="left">dsl := r[d]</td>
</tr>
<tr class="odd">
<td align="left">addl</td>
<td align="left">EXP</td>
<td align="left">e,0a</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] + r[b] + lsb rem</td>
</tr>
<tr class="even">
<td align="left">subl</td>
<td align="left">EXP</td>
<td align="left">e,0b</td>
<td align="left"></td>
<td align="left">rem#r[d] := r[a] - r[b] + slb rem</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="instructions"><a href="#instructions">Instructions</a></h2>
<h3 id="load"><a href="#load">load</a></h3>
<table>
<tbody>
<tr class="odd">
<td align="left">format</td>
<td align="left">RX</td>
</tr>
<tr class="even">
<td align="left">general form</td>
<td align="left">load Rd,disp[Ra]</td>
</tr>
<tr class="odd">
<td align="left">effect</td>
<td align="left">reg[Rd] := mem[disp+reg[Ra]]</td>
</tr>
<tr class="even">
<td align="left">asm example</td>
<td align="left">load R3,$2b8e[R5]</td>
</tr>
<tr class="odd">
<td align="left"></td>
<td align="left">load R12,count[R0]</td>
</tr>
<tr class="even">
<td align="left"></td>
<td align="left">load R6,arrayX[R2]</td>
</tr>
</tbody>
</table>
<p>load. The effective address is calculated. The word at this address is fetched from the memory, and loaded into the destination register.</p>
<h3 id="mul-multiply-signed-integers"><a href="#mul-multiply-signed-integers">mul (multiply signed integers)</a></h3>
<h3 id="add"><a href="#add">add</a></h3>
<p>add. The two operands are fetched from registers, added, and the sum is loaded into the destination register.</p>
<p>The following table shows the complete instruction set. The instructions are in order of increasing operation code.</p>
<h1 id="assembly-language"><a href="#assembly-language">Assembly Language</a></h1>
<p>An assembly language provides a reasonably readable notation for writing machine language programs. An instruction in machine language is just one or more words (often written in hexadecimal notation), while the corresponding instruction in assembly language uses mnemonic names so the programmer doesn't have to memorise all the operation codes, addresses of variables, and so on. However, the assembly language still gives the programmer complete control over a program, down to the last bit.</p>
<p>Computer hardware executes machine language, which is hard for humans to read because it consists entirely of numbers. Assembly language is a way of expressing a machine language program in a readable way. It uses names for instructions and variables, as well as other notations to make the code easier to understand.</p>
<h2 id="notation"><a href="#notation">Notation</a></h2>
<p>Constants can be written in decimal, hexadecimal, or binary.</p>
<ul>
<li><p>Decimal constants consist of a sequence of digits, with an optional leading - sign. Examples: 42 55039 -1</p></li>
<li><p>Hexadecimal constants are written with a dollar sign $ followed by four hex digits (0 1 2 3 4 5 6 7 8 9 a b c d e f). Examples: <span class="math">0249</span>c78a</p></li>
<li><p>Binary constants are written with a hash sign # followed by any number of 0 or 1 characters. You can write fewer than 16 bits; they will be padded on the left with zeros. Examples: #1101 #000100000001101</p></li>
</ul>
<h2 id="assembly-instruction-fields"><a href="#assembly-instruction-fields">Assembly instruction fields</a></h2>
<p>An assembly language statement consists of three fields. A field is a string of non-space characters, and fields must be separated by spaces. The fields are:</p>
<ul>
<li><p>Label. This field is optional: if there is a label, it must begin in the first character of a line. If the first character is a space, then that line has no label. A label is similar to a variable name in a programming language. It must begin with a letter, and may contain letters, digits, and underscore characters.</p></li>
<li><p>Operation. This is the first field that appears after white space in the statement. The operation is the name of an instruction.</p></li>
<li><p>Operands. This field specifies the registers and memory addresses used by an instruction.</p></li>
<li><p>Comment. Everything on a line after a semicolon character is a comment, and is ignored by the assembler.</p></li>
</ul>
<h2 id="expressions"><a href="#expressions">Expressions</a></h2>
<p>An expression denotes a 16-bit word. Usually they are used to specify a word of machine language, either an address or a data constant.</p>
<p>Syntax of expressions</p>
<h2 id="assembly-language-statements"><a href="#assembly-language-statements">Assembly language statements</a></h2>
<h3 id="instructions-1"><a href="#instructions-1">Instructions</a></h3>
<h3 id="directives"><a href="#directives">Directives</a></h3>
<p>A directive is a statement that doesn't generate an instruction, but which gives further information about how to translate the program to object code.</p>
<h4 id="module-statement"><a href="#module-statement">Module statement</a></h4>
<pre><code>modname   module</code></pre>
<p>The module statement, if present, declares the name of the module. It must be the first statement in the program, apart from full line comments and blank lines. A file may contain only one module statement, and if the statement &quot;foo module&quot; is present the file name should be foo.asm.txt.</p>
<p>Examples</p>
<pre><code>quicksort module
main      module
myprog    module</code></pre>
<p>name import export name</p>
<h2 id="object-language-statements"><a href="#object-language-statements">Object language statements</a></h2>
<p>hex4 means a 4-digit hexadecimal constant, such as 3b9f.</p>
<p>name means an identifier, beginning with a letter and comprising letters, digits, _</p>
<p>org hex4 set location counter data hex4 ... hex4 load words, incrementing loc counter relocate hex4 add relocation to word at address external name insert value of external name</p>
<h2 id="assembly-listing"><a href="#assembly-listing">Assembly listing</a></h2>
<p>The first section of the assembly listing shows each line of the source program. The line number appears first, followed by the memory address that the instruction on this line will be placed in. The address is given as a 4 digit hexadecimal number, and it is binary (not two's complement). Next comes the machine language code generated by the line of source code. If the line contains a two-word instruction, there will be two 4-digit hexadecimal values; for a one-word instruction there will be one hex number, and if the line doesn't produce any code these fields will be blank. After the code, the original source statement appears.</p>
<p>The second section of the assembly listing is the <em>Symbol Table</em>. This shows each identifier (or &quot;symbol&quot;) that appears in the program, the address allocated for the symbol, the source code line where it was defined, and the source code lines where it was used.</p>
<h1 id="linker"><a href="#linker">Linker</a></h1>
<p>The linker is not implemented in this version of the application.</p>
<h1 id="programming-the-sigma16-architecture"><a href="#programming-the-sigma16-architecture">Programming the Sigma16 architecture</a></h1>
<p>Coming soon.</p>
<h1 id="using-the-graphical-user-interface"><a href="#using-the-graphical-user-interface">Using the graphical user interface</a></h1>
<p>Coming soon</p>
<h1 id="about-the-software"><a href="#about-the-software">About the software</a></h1>
<p>Sigma16 is built using the Haskell programming language and the Hydra hardware description language. The documentation is written in markdown and prepared for a web browser using pandoc.</p>
<ul>
<li><a href="file:README.html">README</a></li>
<li><a href="file:LICENSE.html">LICENSE</a></li>
<li><a href="file:LICENSE_GPL3.html">Full text of GPL3 license</a></li>
</ul>
<h2 id="changes-underway"><a href="#changes-underway">Changes underway</a></h2>
<p>Support relocatable code</p>
<ul>
<li>Change jump, jumpt, jumpf, jal to use pc-relative addressing</li>
<li>Introduce a jalext that uses indexed absolute address, for external</li>
</ul>
<p>User flags register</p>
<ul>
<li>Carry output</li>
<li>Overflow</li>
<li>Carry input</li>
</ul>
<p>System flags register * System status * Interrupts enabled</p>
<p>Arithmetic Add/subtract with carry</p>
<p>Input/Output dma channels Ready Ack</p>
<h1 id="installation"><a href="#installation">Installation</a></h1>
<p>This is free and open source software and is distributed under the GPL License, either version 3 or (at your option) any later version. See the LICENSE and LICENSE_GPL3 files. This program is experimental software, and is under development.</p>
<h2 id="using-a-precompiled-installation"><a href="#using-a-precompiled-installation">Using a precompiled installation</a></h2>
<h2 id="building-from-source"><a href="#building-from-source">Building from source</a></h2>
<p>Notes: compiling using a sandbox</p>
<p>cabal sandbox init cabal sandbox add-source C:/cygwin64/home/jtod/main/research/Hydra/Hydra-0.8.8 cabal install --only-dependencies cabal configure cabal build ... cabal sandbox delete</p>
<h3 id="hiding-the-console-on-windows"><a href="#hiding-the-console-on-windows">Hiding the console on Windows</a></h3>
<p>See http://projects.haskell.org/gtk2hs/archives/2005/06/23/hiding-the-console-on-windows/</p>
<p>The way to hide the console window it is to pass a special linker option when compiling your program:</p>
<p>ghc --make Foo.hs -optl-mwindows</p>
<h2 id="using-a-pre-compiled-directory"><a href="#using-a-pre-compiled-directory">Using a pre-compiled directory</a></h2>
<p>There may be a pre-compiled version for your platform. If so, this would be a directory (folder) containing all the files needed.</p>
<h3 id="compiling-from-source"><a href="#compiling-from-source">Compiling from source</a></h3>
<h3 id="prerequisite-software"><a href="#prerequisite-software">Prerequisite software</a></h3>
<p>To compile Hydra, you need the Glasgow Haskell Compiler (ghc). In addition, some but not all of the features require ghc to be installed on the computer on which you're running Hydra. Thus it is possible to compile Hydra on one computer and then to copy the binaries to another.</p>
<p>To check whether you have an up-to-date ghc installed, enter</p>
<pre><code> ghc --version</code></pre>
<p>See the file Hydra.cabal for specific dependencies: the particular version of ghc that is required, and the auxiliary packages that need to be installed. These include:</p>
<h1 id="reference"><a href="#reference">Reference</a></h1>
<h2 id="summary-of-notation"><a href="#summary-of-notation">Summary of notation</a></h2>
<p>ea m[ea] r[d] r[a] r[b] q#r[d] lsb q</p>
</body>
</html>
